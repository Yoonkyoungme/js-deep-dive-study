# 13.1 스코프란?
## 스코프
> `스코프` 
> : 유효범위; 변수에 접근할 수 있는 범위; 식별자를 검색할 때 사용하는 규칙

- 함수 매개변수의 스코프(유효범위): 함수 몸체 내부
```javascript
function add(x, y) {
    console.log(x, y); // 2 5
    return x + y;
}
add(2, 5);

console.log(x, y); // ReferenceError: x is not defined
```

- 중첩
```javascript
// var1: 코드의 가장 바깥 영역에서 선언한 변수
var var1 = 1;

if (true) {
    // var2: 코드 블록 내에서 선언한 변수
    var var2 = 2; 
    if (true) {
        // var3: 중첩된 코드 블록 내에서 선언한 변수
        var var3 = 3; 
    }
}

function foo() {
    // var4: 함수 내에서 선언한 변수
    var var4 = 4; 
    function bar() {
        // var5: 중첩된 함수 내에서 선언한 변수
        var var5 = 5; 
    }
}

console.log(var1); // 1
console.log(var2); // 2
console.log(var3); // 3
console.log(var4); // ReferenceError: var4 is not defined
console.log(var5); // ReferenceError: var5 is not defined
```
변수는 자신이 선언된 위치에 의해 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.
변수뿐만 아니라 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)에 해당된다. 
따라서, 스코프는 "변수를 검색할 때 사용하는 규칙"보다 ** "식별자를 검색하는 규칙" **이 더 적합하다.


## 식별자 결정
> `식별자 결정` 
> : 자바스크립트 엔진이 이름이 같은 두 개의 변수 중 어떤 변수를 참조해야 할 것인지 결정하는 것.

자바스크립트 엔진은 코드를 실행할 때 `코드의 문맥`을 고려한다. 

    ⚠️ 코드의 문맥과 환경
    - 렉시컬 환경: 실행할 스코프 범위 안에 있는 변수와 함수를 프로퍼티로 저장하는 객체; "코드가 어디서 실행되며 주변에 어떤 코드가 있는지"를 뜻하며, 코드의 문맥을 이룬다. 
    - 실행 컨텍스트: 실행하고 있는 함수를 트래킹하기 위한 특별한 자료 구조; 모든 코드를 평가하고 실행한다.
    --> 23장

- 예제
같은 이름(`x`)의 변수 출력(①, ②)
```javascript
var x = 'global';
function foo() {
    var x = 'local';
    console.log(x); // ① local
}
foo();
console.log(x); // ② global
```
스코프를 통해 어떤 변수를 참조할 것인지 결정한다!

<img width="440" alt="스크린샷 2023-08-31 오후 2 32 53" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/92731c06-7265-453c-a488-efbb4a33bdb5">
 - 전역 스코프?
    - 코드의 가장 바깥 영역에 선언된 x변수 
    - 어디서든 참조 가능
 - foo 함수 스코프?
    - foo 함수 내부에서 선언된 x 변수
    - foo 함수 외부에서 참조 불가능



## 스코프의 장점 및 특성
- 스코프(유효 범위)를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.(cf.디렉토리와 파일)
- 스코프 내 식별자는 유일해야 한다.
- `네임스페이스`

> ❓ 네임스페이스
> 구분이 가능하도록 정해놓은 범위나 영역, 이름 공간을 선언하여 다른 공간과 구분하도록 한다.


    ⚠️ var 키워드로 선언한 변수의 중복 선언
    `var` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용됨. 
    다만 변수값이 재할당 된다.
    ```javascript
    function foo() {
        var x = 1;
        var x = 2;
        console.log(x); // 2
    }
    foo();
    ```
    * `let`이나 `const` 키워드로 선언된 변수는 같은 스코프 내 중복 선언을 허용하지 않음.


# 13.2 스코프의 종류
- 전역 스코프와 지역 스코프
<img width="439" alt="스크린샷 2023-08-31 오후 3 20 22" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/1e1b0059-aa4e-4e1d-9902-9efd5406b506">


## 전역과 전역 스코프
`전역`은 코드의 가장 바깥 영역이며, `전역 스코프`를 만든다.
즉, `전역`에 `변수`를 선언하면 `전역 스코프`를 갖는 `전역 변수`가 된다.
**전역 변수는 어디서든지 참조할 수 있다.**

## 지역과 지역 스코프
`지역`은 함수 몸체 내부 영역이며, `지역 스코프`를 만든다.
즉, `지역`에 `변수`를 선언하면 `지역 스코프`를 갖는 `지역 변수`가 된다.
**지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.**

<img width="634" alt="스크린샷 2023-08-31 오후 3 26 02" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/4340aa98-d698-4946-a695-6cdf63ccd8c5">


# 13.3 스코프 체인
> `스코프 체인`
> 스코프가 계층적으로 연결된 것

> `함수의 중첩`
> 함수 몸체 내부에서 함수가 정의된 것
> - 중첩 함수: 함수 몸체 내부에 정의한 함수
> - 외부 함수: 중첩 함수를 포함하는 함수

- 스코프의 중첩
함수의 중첩이 발생하면, 함수의 지역 스코프 역시 중첩된다.
**즉, 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다.**
 - 외부 함수의 지역 스코프는 중첩 함수의 `상위 스코프`이다.

<img width="634" alt="스크린샷 2023-08-31 오후 3 26 02" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/08e20e4f-fb3f-42a7-b638-adad53b3a544">

<img width="267" alt="스크린샷 2023-08-31 오후 3 38 09" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/41acf723-951c-4fbc-84b9-ede769033bef">

- 스코프 체인: 전역 스코프(최상위 스코프) + outer 함수(지역 스코프) + inner 함수(지역 스코프)

## 스코프 체인에 의한 변수 검색
자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.
따라서, 상위 스코프에서 선언한 변수를 하위 스코프에서 참조할 수 있다.
절대 하위 스코프로 내려가면서 식별자를 검색하지 않는다.

    * 렉시컬 환경
    스코프 체인은 렉시컬 환경을 실제로 생성한다.(물리적 실체)
    변수 선언 -> 변수 식별자의 자료구조에서의 key 등록 -> 변수 할당 -> 변수 식별자에 해당하는 값 변경
    -> 23장 "실행 컨텍스트"

<img width="634" alt="스크린샷 2023-08-31 오후 3 26 02" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/78716896/01f57137-5351-4b1d-a102-e527e9eb621d">


    상위 스코프에서 유현한 변수는 하위 스코프에서 자유롭게 참조 가능!
    하위 스코프에서 유효한 변수를 상위 스코프에서는 참조 불가능!
    (cf. 상속)

## 스코프 체인에 의한 함수 검색
- 예제
`전역`에서 정의된 `foo` 함수 & `bar` 함수 내부에 정의된 `foo` 함수

```javascript
function foo() {
 console.log('global function foo');
}

function bar() {
    // 중첩 함수
    function foo() {
        console.log('local function foo');
    }
 foo(); // ①
}
bar();
```
`foo`, `bar` 함수는 모두 함수 이름과 동일한 이름의 식별자에 할당된다.
함수를 호출하면 자바스크립트 엔진은 식별자 `foo`를 검색한다.
**스코프 적용**하기 때문에 

    <12.4.1절 "함수 선언문" & 12.4.3절 "함수 생성 시점과 함수 호이스팅">
    함수 선언문으로 함수를 정의하면, 런타임 이전에 함수 객체가 먼저 생성된다.
    자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.




# 13.4 함수 레벨 스코프
**지역 스코프는 코드 블록이 아닌 함수에 의해 생성된다.**
`var` 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.

> JavaScript와 다른 언어의 차이점
> `블록 레벨 스코프`
> 대부분의 프로그래밍 언어는 함수 몸체뿐만 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 생성한다.

- 예제
두 번의 `x` 변수 선언
```javascript
var x = 1;
if (true) {
 var x = 10;
}
console.log(x); // 10
```
 - 전역으로 선언된 `x` 변수
 - `var` 키워드로 선언되었지만, 함수 몸체가 아닌 코드 블록 내 선언된 전역 변수 `x`
 - 결과: 중복 할당되었으므로, 변수 값 변경

    [ 15장 ] let, const 키워드와 블록 레벨 스코프
    ES6에서 도입된 `let`, `const` 키워드는 블록 레벨 스코프를 지원한다.

# 13.5 렉시컬 스코프

```javascript
var x = 1;

function foo() {
    var x = 10;
    bar();
}

function bar() {
    console.log(x);
}

foo(); // 1
bar(); // 1
```

- `bar` 함수의 상위 스코프
    1. 함수를 어디서 호출했는가?
    2. 함수를 어디서 정의했는가?

1. 함수를 어디서 호출했는가?
> `동적 스코프` 
> 함수가 호출되는 시점에 동적으로 상위 스코프 결정
> (함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없으므로)
`bar` 함수의 상위 스코프: `foo` 함수의 지역 스코프 + 전역 스코프

2. 함수를 어디서 정의했는가? ✔️
> `렉시컬 스코프`, `정적 스코프`
> 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정
> 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프이며, 이를 기억한다.
`bar` 함수의 상위 스코프: 전역 스코프





