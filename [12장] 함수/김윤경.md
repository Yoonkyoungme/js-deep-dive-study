## 함수

> `함수`는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 `하나의 실행 단위로 정의`한 것이다.

<br />
<br />

## 함수를 사용하는 이유

- `코드의 재사용`
  - 동일한 작업을 반복적으로 수행하는 코드를 함수로 만들어 사용하는 것이 효율적이다.
- `유지보수 편의성 & 코드의 신뢰성`
  - 같은 코드의 중복으로 인해 코드를 수정할 때 걸리는 시간과 실수할 가능성을 줄일 수 있다.
- `코드의 가독성`
  - 적절한 함수 이름은 함수 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕고, 이는 코드의 가독성을 향상시킨다.

<br />
<br />

## 함수 리터럴

> `리터럴`: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식을 말한다. 즉, 리터럴은 `값을 생성 하기 위한 표기법`이다.

> 함수 리터럴 구성 요소

- 함수 이름
  - 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다.
  - 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.
    - 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다.
  - 함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수(named function), 이름이 없는 함수를 무명/익명 함수(anonymous function)라 한다.
- 매개변수 목록
  - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.
  - 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다.
  - 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.
- 함수 몸체
  - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.
  - 함수 몸체는 함수 호출에 의해 실행된다.

```js
// 변수에 "함수 리터럴"을 할당
var f = function add(x, y) {
  return x + y;
};
```

<br />

> 함수는 `객체(object)`이다. (일급 객체)

- 일반 객체는 호출할 수 없지만 `함수는 호출할 수 있다.`
- 일반 객체에는 없는 `함수 객체만의 고유한 프로퍼티를 갖는다.`

<br />
<br />

## 함수 정의

> 자바스크립트에서 함수를 정의하는 방법에는 `4가지`가 있다.

- 정의된 함수는 자바스크립트 엔진에 의해 평가되어 `함수 객체가 된다.`

1. `함수 선언문`

```js
function add(x, y) {
  return x + y;
}
```

2. `함수 표현식`

```js
var add = function (x, y) {
  return x + y;
};
```

3. `Function 생성자 함수`

```js
var add = new Function("x", "y", "return x + y");
```

4. `화살표 함수(ES6)`

```js
var add = (x, y) => x + y;
```

```
💡 변수 선언과 함수 정의
- "변수" -> 선언(declaration)한다.
- "함수" -> 정의(definition)한다.
```

<br />

### 코드의 문맥에 따른 자바스크립트 엔진의 함수 해석

> 자바스크립트 엔진은 `코드의 문맥`에 따라 동일한 함수 리터럴을 함수 표현식 or 함수 선언문으로 해석하는 경우가 있다.

```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};
// 함수 호출 console.log(add(2, 5)); // ➔ 7
```

- `{ }`은 `코드 블록` 일 수도 있고, `객체 리터럴`일 수도 있다. → `{ }은 중의적 표현`
  - `{ }`이 `단독`으로 존재 → 자바스크립트 엔진은 `{ }을 블록문으로 해석`
  - `{ }`이 `값으로 평가`되어야 할 문맥에서 `피연산자`로 사용될 경우 → 자바스크립트 엔진은 `{ }을 객체 리터럴로 해석`
- 함수도 이와 같다.
  - `함수 리터럴`이 단독으로 사용된다. → `함수 선언문`으로 해석
  - `함수 리터럴`이 값으로 평가되어야 하는 문맥(함수 리터럴을 변수에 할당 or 피연산자로 사용) → `함수 리터럴 표현식`으로 해석

<br />

## 함수 선언문과 함수 리터럴 표현식

> 함수 선언문과 함수 리터럴 표현식은 함수가 생성되는 것은 동일하다. 다만, `호출에서 차이가 있다.`

```js
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {
  console.log("foo");
}
foo(); // ➔ foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() {
  console.log("bar");
});
bar(); // ➔ ReferenceError: bar is not defined
```

- 위 예제에서 `함수 선언문`으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다.
  - `자바스크립트 엔진`은 생성된 함수를 호출하기 위해 `함수 이름과 동일한 이름의 식별자를 암묵적으로 생성`하고, 거기에 함수 객체를 할당한다.

<br />

1️⃣ 함수 리터럴 표현식으로 함수 호출 시 메모리 구조

<div style="text-align:center;">
  <img width="573" alt="함수 리터럴 표현식으로 함수 호출 시 메모리 구조" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/100656920/207d6f42-a2cf-4ec1-9dac-fc905657e78f">
</div>

- 함수 몸체 외부에서는 함수 이름으로 `함수를 참조할 수 없다.` = 함수 몸체 외부에서는 함수 이름으로 `함수를 호출할 수 없다.`
- 즉, 함수를 가리키는 `식별자가 없다는 것과 같은 의미`이다.

<br />

2️⃣ 함수 선언문으로 함수 호출 시 메모리 구조

<div style="text-align:center;">
 <img width="580" alt="함수 선언문으로 함수 호출 시 메모리 구조" src="https://github.com/Yoonkyoungme/js-deep-dive-study/assets/100656920/c2fdc112-9bfd-4338-a81b-258744b7915b">
</div>

- 자바스크립트 엔진은 `함수 선언문을 해석해 함수 객체를 생성`한다.
- 생성된 함수 객체를 가리키는 `유효한 식별자가 필요`하다.
- 따라서, 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 `암묵적으로 생성하고, 거기에 함수 객체를 할당한다.`

<br />

> 결국, 함수는 함수 이름으로 호출하는 것이 아니라, `함수 객체를 가리키는 식별자로 호출하는 것이다.`

- `함수 이름`은 `함수 몸체 내부에서만 유효한 식별자`이므로 함수 이름으로 함수를 호출할 수 없다.

<br />

### 함수 생성 시점과 함수 호이스팅

> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다.

```js
// 함수 참조
console.dir(add); // ➔ ƒ add(x, y)
console.dir(sub); // ➔ undefined

// 함수 호출
console.log(add(2, 5)); // ➔ 7
console.log(sub(2, 5)); // ➔ TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

- `함수 호이스팅`: 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

- `함수 선언문`: 코드의 어떤 위치에서든 선언되면 스코프의 맨 위로 끌어올려진다.

  - 이것은 함수 선언문을 선언한 위치와 관계없이 함수가 스코프 내 어디서든 호출 가능하다는 것을 의미한다.
  - 즉, 함수 선언문은 호이스팅되어 선언과 함께 초기화된다.
  - 이것은 함수 선언문이 코드 블록 내 어디에서든 사용할 수 있다는 이점을 제공하지만, 코드를 읽을 때 함수가 실제로 정의된 위치를 파악하기 어렵게 만들 수 있다.

- `함수 표현식`: 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.
  - 즉, 변수가 선언되면 호이스팅되지만, 할당된 함수는 호이스팅되지 않는다. (변수는 선언됐지만 함수가 할당되기 전에는 undefined로 초기화된다.)
  - 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러가 발생한다.
  - 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.

```
💡 함수 호이스팅 vs 변수 호이스팅

✔️ 공통점: 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일하다. (호이스팅 현상)
✔️ 차이점: 변수는 선언과 할당이 분리되고 초기화되지 않은 경우 undefined로 초기화되지만, 함수는 선언과 몸체가 함께 호이스팅되어 사용 가능하다.
```

<br />
<br />

## 함수 호출

- 함수의 `매개변수(parameter)`는 함수 몸체 내부에서만 참조할 수 있다. 즉, `매개변수의 스코프(유효 범위)는 함수 내부다.`
- 함수는 매겨변수의 개수와 인수(argument)의 개수가 일치하지 않아도 된다.
  - 인수가 매개변수보다 부족하면, 나머지 매개변수에 대해서는 `암묵적으로 undefined`로 할당한다.
  - 인수가 매개변수보다 많으면, 모든 인수는 `암묵적으로 arguments 객체의 프로퍼티로 보관`된다.

```js
function add(x, y) {
  console.log(x, y); // ➔ 1 2
  return x + y;
}

add(1, 2);

// add 함수의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y); // ➔ ⚠️ ReferenceError: x is not defined

// 매개변수의 개수 > 인수의 개수 → 나머지 매개변수 undefined
function mul(x, y) {
  console.log(x, y); // ➔ 1 undefined
}
mul(1);

// 매개변수의 개수 < 인수의 개수 → arguments에 보관
function sub(x, y) {
  console.log(arguments); // ➔ Arguments [3, 2, 1]
  return x - y;
}
sub(3, 2, 1); // ➔ 1
```

<br />

### 자바스크립트 문법상의 문제

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 `동적 타입 언어`다. 따라서 자바스크립트 함수는 `매개변수의 타입을 사전에 지정할 수 없다.`

- 따라서, 자바스크립트의 경우 `함수를 정의할 때, 인수가 전달되었는지 확인할 필요가 있다.`
  1. `typeof 연산자`를 사용하는 방법
  2. 인수가 전달되지 않은 경우 `단축 평가 를 사용하는 방법
  3. `매개변수에 기본값(default value)`을 할당하는 방법 (ES6에서 도입됨)

```js
// 1️⃣ typeof 연산자로 arguments 문제 방지
function add(x, y) {
  if (typeof x !== "number" || typeof y !== "number") {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.
    throw new TypeError("인수는 모두 숫자 값이어야 합니다.");
  }

  return x + y;
}

console.log(add(1, 2)); // ➔ 3
console.log(add("a", "b")); // ➔  TypeError: 인수는 모두 숫자 값이어야 합니다.

// 2️⃣ "단축 평가"로 arguments 문제 방지
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}
console.log(add(1, 2, 3)); // ➔ 6
console.log(add(1, 2)); // ➔ 3
console.log(add(1)); // ➔ 1
console.log(add()); // ➔ 0

// 3️⃣ parameter default value 설정으로 argument 문제 방지
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}
console.log(add(1, 2, 3)); // ➔ 6
console.log(add(1, 2)); // ➔ 3
console.log(add(1)); // ➔ 1
console.log(add()); // ➔ 0
```

<br />

### 매개변수의 최대 개수

- 함수의 매개변수는 코드를 이해하는 데 방해되는 요소이므로 최대 3개 이상을 넘지 않는 것을 권장한다. 적을수록 좋다.
- 매개변수의 개수가 많다는 것은 함수가 여러 가지 일을 한다는 증거이므로 바람직하지 않다.
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.

<br />
<br />

## 여러가지 함수

- `즉시 실행 함수(IIFE, Immediately Invoked Function Expression)`

  > 함수 정의와 동시에 즉시 호출되는 함수이다. 단 한 번만 호출되며 다시 호출할 수 없다.

  - 즉시 실행 함수는 `반드시 그룹 연산자( ... )로 감싸야 한다.`
  - 즉시 실행 함수는 `함수 이름이 없는 익명 함수를 사용하는 것이 일반적`이다.

  ```js
  // 익명 즉시 실행 함수
  (function () {
    var a = 3;
    var b = 5;
    return a * b;
  })();

  // 기명 즉시 실행 함수
  (function foo() {
    var a = 3;
    var b = 5;
    return a * b;
  })();
  foo(); // ReferenceError: foo is not defined
  ```

  <br />

- `재귀 함수(recursive function)`

  > 재귀 함수는 자기 자신을 호출 하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.

  - 재귀 함수는 `반복되는 처리를 위해 사용`한다.
  - 재귀 함수는 자신을 무한 재귀 호출한다. 따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 `탈출 조건`을 반드시 만들어야 한다.

<br />

- `중첩 함수(nested function) == 내부 함수(inner function)`

  > 함수 내부에 정의된 함수이다.

  - 중첩 함수는 외부 함수(중첩 함수를 포함하는 함수) 내부에서만 호출할 수 있다.
  - 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 `헬퍼 함수(helper function)` 역할을 한다.

  ```js
  function outer() {
    var x = 1;

    // 중첩 함수 == 내부 함수
    function inner() {
      var y = 2;

      // 외부 함수의 변수 참조
      console.log(x + y); // ➔ 3
    }

    inner();
  }

  outer();
  ```

  <br />

- `콜백 함수(callback function)`

  > 함수의 매개변수(parameter)를 통해 다른 함수의 내부로 전달되는 함수

  - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 `고차 함수(Higher-Order Function, HOF)`라고 한다.
  - 콜백 함수는 고차 함수에 의해 호출된다.
  - 고차 함수는 필요에 따라 콜백 함수에 인수(argument)를 전달할 수 있다. → 그렇기 때문에 고차함수에 콜백함수 전달 시 `콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.`
  - 함수는 `일급 객체`이므로 함수의 매개변수를 통해 함수를 전달 가능하다.
  - 그로인해, `함수는 더 이상 내부로직에 강력히 의존하지 않고 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 유연한 구조를 갖는다.`

  ```js
  // 외부에서 전달받은 func를 n만큼 반복 호출
  function repeat(n, f) {
    for (var i = 0; i < n; i++) {
      f(i); // i를 전달하면서 f를 호출
    }
  }

  var logAll = function (i) {
    console.log(i);
  };

  // 반복 호출할 함수를 인수로 전달
  repeat(5, logAll); // ➔ 0 1 2 3 4

  var logOdds = function (i) {
    if (i % 2) console.log(i);
  };

  // 반복 호출할 함수를 인수로 전달
  repeat(5, logOdds); // ➔ 1 3
  ```
