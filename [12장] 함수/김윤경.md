<br />
<br />

## 값에 의한 호출 vs 참조에 의한 호출

- `값에 의한 호출(call by value)` : 함수 호출시 매개변수에 `원시 값(primitive value)을 전달`
- `참조에 의한 호출(call by reference)` : 함수 호출시 매개변수에 `객체(object) 를 전달`

<br />

### 값에 의한 호출

- 원시 값은 `변경 불가능한 값(immutable value)` 성질
- 즉, 원시 타입의 argument 는 `값 자체가 복사되어 매개변수에 전달`
- 이 값을 변경(재할당을 통한 변경)해도 `원본은 훼손되지 않는다. ( side effect X )`

<br />

### 참조에 의한 호출

- 객체는 `변경 가능한 값(mutable value)` 성질
- 즉, 객체 argument 는 `참조 값이 복사되어 매개변수에 전달`
- 참조 값을 통해 전달한 객체를 변경할 경우 `원본이 훼손된다. ( side effect O )`

```
[ 💩 참조에 의한 호출의 문제점 ]

= 객체가 변경될 수 있기 때문에 "상태 변화 추적"이 어렵다.
```

```js
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = "WIEEE";
}

// 외부 상태
var num = 100; // 원시 값
var person = { name: "WI" }; // 객체

console.log(num); // 100
console.log(person); // { name: 'WI' }

changeVal(num, person);

console.log(num); // 100
console.log(person); // { name: 'WIEEE' } 💩
```

![원시 값 전달과 참조 값 전달](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbgAgqP%2FbtrmEi0ScBA%2FwrhIYb7DMZRfh5wWQqoKMK%2Fimg.png)

- 해결 방법 중
  - 객체를 `불변 객체(immutable object)` 로 만들어 사용하는 것
    - 객체의 복사본을 새롭게 생성하는 것은 비용(cost)이 원본 객체 규모에 따라 커질 수 있다.
    - 하지만, 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만들 수 있다.
    - 방법으로는 `깊은 복사(deep copy)` 를 통해 새로운 객체를 생성하고 재할당한다. → `side effect X`

```js
[ 💡 순수 함수 ]

+ 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 "순수 함수"
+ 순수 함수를 통해 부수효과(side effect)를 최대한 억제하고 오류를 피해 프로그램 안정성을 높인다. = "함수형 프로그래밍"
```

